[DEFAULT]
CSL_PATH = /net/${HOSTNAME}/data1/ssli/cosmosis/cosmosis-standard-library
COSMO_PATH = /net/raam/data1/surfdrive_ssli/Projects/6CosmicShear_RB/CosmicShearRB/Cosmo
KCAP_PATH = %(COSMO_PATH)s/modules/kcap
DATA_PATH = %(COSMO_PATH)s/data/KV450_fiducial
RUN_NAME = KV450_fiducial
OUTPUT_DIR = %(COSMO_PATH)s/output/KV450_fiducial

[runtime]
sampler = test

[test]
save_dir=%(OUTPUT_DIR)s/output_%(RUN_NAME)s
fatal_errors=T

[output]
filename=%(OUTPUT_DIR)s/samples_%(RUN_NAME)s.txt
format=text

[metropolis]
samples = 10000
nsteps = 1

[multinest]
;wrapped_params = cosmological_parameters--omega_b   cosmological_parameters--h0
max_iterations=100000
multinest_outfile_root=%(OUTPUT_DIR)s/multinest_%(RUN_NAME)s_
resume=F
; from Joe:- For a quick run:
live_points=250
efficiency=0.8
tolerance=0.1
constant_efficiency=F
;    ~ 140k evaluations
;    ~ 9k independent samples
;    Few enough samples that the plots will be too scrappy to use in publications. 
;    Estimated mean and covmat will still be good to a few percent
;    Evidence will be a bit off compared to other estimates.
;- Suggested standard run:
;live_points=500
;efficiency=0.3
;tolerance=0.1
;constant_efficiency=F
;    ~ 350k evaluations
;    ~ 20k independent samples
;    Plots should be fine with some small smoothing or Schuhman's transformation.
;    Reasonable evidence
;- A mega-run:
;live_points=1000
;efficiency=0.05
;tolerance=0.1   
;constant_efficiency=T
;    ~ 1M evaluations
;    ~ 40k independent samples
;    Switching on constant_efficiency speeds up from ~1M samples to ~600k
;    Should only need one or two of these for comparison.

;KV450 fiducial set up
;live_points=1000
;efficiency=0.3
;tolerance=0.5
;constant_efficiency=F
;ins=F

[emcee]
; The emcee sampler uses the concept of walkers, a collection
; ; of live points.  Sampling is done along lines that connect
; ; pairs of walkers.  The number of walkers must be at least
; ; 2*nparam + 1, but in general more than that usually works
; ; better.
burn=0.3
walkers = 72
; ; This many samples is overkill, just to make the plots
; ; look a lot nicer
samples = 10000
;;1000000
; ; This is the interval at which convergence diagnostics
; ; are performed
nsteps = 5
;

[pipeline]
; The list of modules to be run, in this order.
; The modules named here must appear as sections below.
modules = sample_ln_As one_parameter_hmcode camb consistency extrapolate_power load_nz source_photoz_bias linear_alignment projection add_intrinsic cl2xi derived_parameters mini_2pt_like

values = %(COSMO_PATH)s/config/KV450_values.ini
priors = %(COSMO_PATH)s/config/KV450_priors.ini

likelihoods = mini_2pt_like
extra_output = cosmological_parameters/omega_m cosmological_parameters/A_s cosmological_parameters/sigma_8 cosmological_parameters/S8 cosmological_parameters/h0 cosmological_parameters/cosmomc_theta

; We can get a little more output during the run by setting some values.
quiet=F
timing=T
debug=F

[sample_ln_As]
file = %(KCAP_PATH)s/sample_ln_As.py

[one_parameter_hmcode]
file = %(KCAP_PATH)s/one_parameter_hmcode.py
a_0 = 0.98
a_1 = -0.12

[camb]
file = %(KCAP_PATH)s/pycamb/camb_interface.py
;file = %(CSL_PATH)s/boltzmann/camb/camb.so
mode=transfer
lmax=2500
do_reionization = F
;accuracy_boost = 2.0
;high_accuracy_default = T
feedback=0
kmax=20.0
zmin=0.0
zmid=2.0
nz_mid=100
zmax=6.0
nz=150
background_zmax=6.0
background_zmin=0.0
background_nz=6000
halofit_verion=mead
theta_H0_range=10 150

[consistency]
file = %(CSL_PATH)s/utility/consistency/consistency_interface.py

[extrapolate_power]
file=%(CSL_PATH)s/boltzmann/extrapolate/extrapolate_power.py
kmax=500.0

[load_nz]
file = %(KCAP_PATH)s/load_nz/load_nz.py
filepath = %(DATA_PATH)s/nofz/Nz_DIR_z0.1t0.3.asc %(DATA_PATH)s/nofz/Nz_DIR_z0.3t0.5.asc %(DATA_PATH)s/nofz/Nz_DIR_z0.5t0.7.asc %(DATA_PATH)s/nofz/Nz_DIR_z0.7t0.9.asc %(DATA_PATH)s/nofz/Nz_DIR_z0.9t1.2.asc
histogram = True
output_section = nz_KV450_5bin

[source_photoz_bias]
file = %(CSL_PATH)s/number_density/photoz_bias/photoz_bias.py
mode = additive
sample = nz_KV450_5bin
bias_section = nofz_shifts
interpolation = linear

[linear_alignment]
file = %(CSL_PATH)s/intrinsic_alignments/la_model/linear_alignments_interface.py
method = bk_corrected

[projection]
file = %(CSL_PATH)s/structure/projection/project_2d.py
ell_min = 0.1
ell_max = 5.0e5
n_ell = 400
shear-shear = KV450_5bin-KV450_5bin 
shear-intrinsic = KV450_5bin-KV450_5bin
intrinsic-intrinsic = KV450_5bin-KV450_5bin
verbose = T
get_kernel_peaks = F

[add_intrinsic]
file=%(CSL_PATH)s/shear/add_intrinsic/add_intrinsic.py
position-shear=False

[cl2xi]
;This Nicaea code converts C_ell into xi(theta).
;It is fast and accurate but requires a high ell_max, as shown above
file = %(CSL_PATH)s/shear/cl_to_xi_nicaea/nicaea_interface.so
corr_type = 0

[derived_parameters]
file = %(KCAP_PATH)s/derived_parameters.py
parameters = S8

[mini_2pt_like]
file = %(KCAP_PATH)s/mini_2pt_like.py
n_bin = 5
data_filename = %(DATA_PATH)s/data_vector/KV450_reweight_3x4x4_v2_good_xipm_mcor_5bin.dat
angular_binning_mode = integrate
;9 log-spaced bins between 0.5 and 300.0
angular_bin_edges = 0.5 1.01777898 2.0717481 4.21716333 8.58428037 17.4738002 35.56893304 72.40262468 147.37973879 300.0
cut_xi_plus = 7 8
cut_xi_minus = 0 1 2
order_cov = montepython
order_data = montepython
cov = %(DATA_PATH)s/covariance/cov_analytic_montepython_mcorr.txt
m_correction = -0.0128 -0.0104 -0.0114 0.0072 0.0061
constant_c_offset = T
xi_pm_c_file = %(DATA_PATH)s/systematics/KV450_ALL_c12_treecorr.out
like_name = mini_2pt_like
keep_theory_vector = T
